# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
#   kernelspec:
#     display_name: env (3.11.4)
#     language: python
#     name: python3
# ---

# # 12: Exporting Simulation Results to NIFTI Format
#
# This notebook demonstrates how to take acoustic simulation results generated by OpenLIFU and export them into the NIFTI file format (`.nii` or `.nii.gz`). NIFTI is a widely used standard in medical imaging, and exporting to this format allows you to:
#
# *   Visualize your simulation results (e.g., pressure fields, thermal dose) in common medical imaging software like 3D Slicer, ITK-SNAP, FSLeyes, etc.
# *   Overlay simulation data onto anatomical images (e.g., MRI, CT scans).
# *   Perform further analysis using tools that operate on NIFTI data.
#
# We will generate a simulation, then construct the necessary components (data array and affine matrix) to create a valid NIFTI image.

# ## 1. Imports

# +
from __future__ import annotations

from pathlib import Path

import nibabel  # The primary library for NIFTI I/O in Python
import numpy as np

# OpenLIFU components for running a simulation
from openlifu.bf import Pulse, Sequence, apod_methods, focal_patterns
from openlifu.geo import Point
from openlifu.plan import Protocol
from openlifu.sim import SimSetup  # SimResult is key here
from openlifu.xdc import Transducer

# logging.basicConfig(level=logging.INFO) # Uncomment to see more logs
# -

# ## 2. Setup: Running an OpenLIFU Simulation
#
# First, we need to generate some simulation data. We'll follow a similar procedure to Notebook 03 to set up a `Protocol`, `Transducer`, `Target`, and run `calc_solution` with `simulate=True`.

# +
transducer = Transducer.gen_matrix_array(nx=8, ny=8, pitch=4, kerf=0.5, id="generic_8x8", name="Generic 8x8 Array")

# Define other components for the protocol
f0 = 400e3
pulse = Pulse(frequency=f0, duration=10/f0)
sequence = Sequence(pulse_interval=0.1, pulse_count=1, pulse_train_count=1)
target_pt = Point(position=np.array([0, 0, 40]), units="mm", radius=0.5) # Target at 40mm depth
focal_pattern = focal_patterns.SinglePoint(target_pressure=1.0e6)
apod_method = apod_methods.MaxAngle(max_angle=25)

# Simulation Setup: This defines our grid
# For NIFTI export, it's helpful if the grid is somewhat uniform.
sim_grid_resolution_mm = 0.5 # mm
sim_setup = SimSetup(
    x_extent=(-20, 20), y_extent=(-20, 20), z_extent=(-4, 60), # mm
    spacing=sim_grid_resolution_mm
)
print(f"Simulation Setup: {sim_setup}")

protocol = Protocol(
    id='nifti_export_protocol', name='Protocol for NIFTI Export Example',
    pulse=pulse, sequence=sequence, focal_pattern=focal_pattern,
    apod_method=apod_method, sim_setup=sim_setup
)

# Run the solution calculation with simulation enabled
solution = None
sim_res = None
solution, sim_res, analysis = protocol.calc_solution(
    target=target_pt,
    transducer=transducer,
    simulate=True, # Crucial: We need the simulation result
    scale=True     # Scale to target pressure
)
print("Simulation complete. SimResult object obtained.")

# -

# ## 3. Extracting Data from `SimResult`
#
# The `SimResult` object holds the output of the simulation, including the pressure field and the coordinates of the simulation grid.
# We need to extract:
# 1.  The 3D pressure data as a NumPy array. `SimResult.get_pressure_field()` is expected to provide this.
# 2.  The coordinate vectors for each axis (X, Y, Z). `SimResult.coords` or similar attributes/methods should provide these.

pressure_field_data = sim_res.p_max.astype(np.float32) # Example attribute
x_coords = sim_res.coords['x'] # Example
y_coords = sim_res.coords['y'] # Example
z_coords = sim_res.coords['z'] # Example

# ## 4. Constructing the NIFTI Affine Matrix
#
# The affine matrix is crucial for NIFTI. It defines the orientation and position of the image data in physical space (usually RAS - Right-Anterior-Superior coordinates in mm).
# The affine is a 4x4 matrix that transforms voxel coordinates `(i, j, k, 1)` to physical coordinates `(x, y, z, 1)`.
#
# `[[ Mxx Mxy Mxz Tvx ],`
# ` [ Myx Myy Myz Tvy ],`
# ` [ Mzx Mzy Mzz Tvz ],`
# ` [  0   0   0   1  ]]`
#
# Where `M` is a 3x3 rotation/scaling/skew matrix and `Tv` is a translation vector.
# For a simple grid aligned with axes:
# *   The diagonal of `M` contains voxel spacing (dx, dy, dz).
# *   Off-diagonal elements of `M` are zero (no rotation/skew relative to these axes).
# *   `Tv` is the coordinate of the center of the first voxel (index 0,0,0).

# +
# Voxel spacing (should match sim_setup.resolution if grid is uniform)
dx = x_coords[1] - x_coords[0] if len(x_coords) > 1 else sim_grid_resolution_mm
dy = y_coords[1] - y_coords[0] if len(y_coords) > 1 else sim_grid_resolution_mm
dz = z_coords[1] - z_coords[0] if len(z_coords) > 1 else sim_grid_resolution_mm
print(f"Voxel spacing (dx, dy, dz): ({dx:.2f}, {dy:.2f}, {dz:.2f}) mm")

# Origin: Coordinate of the center of the voxel (0,0,0)
# NIFTI standard often refers to the corner, but nibabel handles center convention well.
# For nibabel, it's common to define the affine such that it maps (0,0,0) voxel index
# to the coordinate of the center of that first voxel.
origin_x = x_coords[0]
origin_y = y_coords[0]
origin_z = z_coords[0]
print(f"Grid origin (center of first voxel): ({origin_x:.2f}, {origin_y:.2f}, {origin_z:.2f}) mm")

# Create the affine matrix.
# Assuming standard OpenLIFU coordinate system (e.g., X, Y, Z)
# and we want NIFTI to align with these axes.
# Common NIFTI orientation is RAS (Right-Anterior-Superior).
# If OpenLIFU's X,Y,Z directly map to X,Y,Z in desired space:
affine_matrix = np.array([
    [dx,  0,  0, origin_x],
    [ 0, dy,  0, origin_y],
    [ 0,  0, dz, origin_z],
    [ 0,  0,  0,        1]
])

# If OpenLIFU uses a different handedness or axis mapping than your NIFTI viewer expects (e.g. LPS vs RAS),
# you might need to flip axes in the affine (e.g., by negating dx or dy) and potentially reorder
# the data array dimensions if you used `np.transpose`.
# For example, if OpenLIFU X is NIFTI -X (LPS X vs RAS X):
# affine_matrix[0,0] = -dx
# affine_matrix[0,3] = origin_x # if origin_x was for the -X direction start.
# This part is highly dependent on coordinate system conventions.
# The affine from test_nifti.py was more complex as it included transducer pose.
# Here, we make a simpler grid-aligned affine.

print("\nConstructed Affine Matrix:")
print(affine_matrix)

# -

# ## 5. Creating and Saving the NIFTI Image
#
# With the data array and affine matrix, we can create a `Nifti1Image` object using `nibabel` and save it.

# +
output_nifti_filename = "12_Exporting_Simulation_to_NIFTI_pnp_output.nii.gz"

# Ensure data is in a suitable orientation for the affine.
# Nibabel expects Fortran-ordered data for standard axial orientations if data is (X,Y,Z).
# If pressure_field_data is (Z,Y,X) from simulation, you might need to transpose it
# and adjust the affine. For now, assume pressure_field_data is (X,Y,Z).
# If not, you might need:
# pressure_field_data_xyz = np.transpose(pressure_field_data, (ax_idx_for_x, ax_idx_for_y, ax_idx_for_z))

print(f"\nCreating NIFTI image with data shape: {pressure_field_data.shape}")
nifti_image = nibabel.Nifti1Image(pressure_field_data, affine_matrix)

# Set spatial units in the header (optional but good practice)
# 1 = NIFTI_UNITS_METER, 2 = NIFTI_UNITS_MM, 3 = NIFTI_UNITS_MICRON
nifti_image.header.set_xyzt_units(xyz=2, t=0) # xyz in mm, t (time) unspecified (0)

# Save the NIFTI image
nibabel.save(nifti_image, output_nifti_filename)
print(f"âœ… Simulation successfully saved to NIFTI file: {Path(output_nifti_filename).resolve()}")
print("You can now open this file in a NIFTI viewer (e.g., ITK-SNAP, 3D Slicer, FSLeyes).")

# -

# ## 6. Important Considerations for NIFTI Export
#
# *   **Coordinate Systems:** This is the most critical and often confusing part. Ensure your affine matrix correctly maps your simulation's voxel indices to a known physical coordinate system (e.g., RAS). Mismatches will lead to incorrect display or registration with other images. The OpenLIFU coordinate system (how X, Y, Z are defined for the transducer and simulation grid) must be understood.
# *   **Data Orientation:** The order of dimensions in your NumPy array (`pressure_field_data`) must match what the affine matrix expects. If your simulation outputs data as `(z, y, x)` but your affine is set up for `(x, y, z)` voxel indexing, you'll need to transpose the data. `nibabel.as_closest_canonical(img)` can sometimes help reorient data to a more standard axial view, but the underlying data-to-affine mapping must be correct.
# *   **Data Type:** `float32` is common for NIFTI images representing continuous values like pressure.
# *   **Header Information:** Setting units (`set_xyzt_units`) and other header fields can be important for compatibility with some software.
# *   **Transducer Position:** If you want to align the simulation NIFTI with a NIFTI representing anatomy where the transducer has a known pose, you'd need to incorporate the transducer's transformation matrix into the NIFTI affine, or register the simulation NIFTI to the anatomical NIFTI using image registration tools. The example here creates a NIFTI in the simulation's own coordinate frame.

# ## 7. Conclusion
#
# This notebook demonstrated a basic workflow for exporting OpenLIFU simulation results to the NIFTI format. This enables visualization and analysis in a wide range of medical imaging tools, facilitating the integration of simulation data with other imaging modalities.
#
# Accurate NIFTI export hinges on correctly defining the affine transformation that links the voxel data to physical space. Careful attention to coordinate systems and data orientation is paramount.

# End of Notebook 12
