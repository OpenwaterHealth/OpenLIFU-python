# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
#   kernelspec:
#     display_name: python3
#     language: python
#     name: python3
# ---

# # 13: Exporting Simulation Results to NIFTI Format
#
# This notebook demonstrates how to take acoustic simulation results generated by OpenLIFU and export them into the NIFTI file format (`.nii` or `.nii.gz`). NIFTI is a widely used standard in medical imaging, and exporting to this format allows you to:
#
# *   Visualize your simulation results (e.g., pressure fields, thermal dose) in common medical imaging software like 3D Slicer, ITK-SNAP, FSLeyes, etc.
# *   Overlay simulation data onto anatomical images (e.g., MRI, CT scans).
# *   Perform further analysis using tools that operate on NIFTI data.
#
# We will generate a simulation, then construct the necessary components (data array and affine matrix) to create a valid NIFTI image.

# ## 1. Imports

# +
import numpy as np
import nibabel # The primary library for NIFTI I/O in Python
from pathlib import Path

# OpenLIFU components for running a simulation
from openlifu.bf import Pulse, Sequence, apod_methods, focal_patterns
from openlifu.geo import Point
from openlifu.plan import Protocol
from openlifu.sim import SimSetup, SimResult # SimResult is key here
from openlifu.xdc import Transducer
from openlifu.db import Database

import logging # Optional: for OpenLIFU internal logs during simulation
# logging.basicConfig(level=logging.INFO) # Uncomment to see more logs
# -

# ## 2. Setup: Running an OpenLIFU Simulation
#
# First, we need to generate some simulation data. We'll follow a similar procedure to Notebook 03 to set up a `Protocol`, `Transducer`, `Target`, and run `calc_solution` with `simulate=True`.

# +
# Load a transducer
transducer = None
db_path_found = None
paths_to_check = [Path.cwd() / "db_dvc", Path.cwd() / ".." / "db_dvc"]
for path_check in paths_to_check:
    if path_check.exists() and path_check.is_dir() and (path_check / "transducers").exists():
        db_path_found = path_check.resolve()
        break

if db_path_found:
    db = Database(db_path_found)
    available_transducers = db.list_transducers()
    if available_transducers:
        trans_id_to_load = 'openlifu_2x400_evt1' if 'openlifu_2x400_evt1' in available_transducers else available_transducers[0]
        try:
            transducer = db.load_transducer(trans_id_to_load)
            print(f"Successfully loaded transducer '{transducer.id}'.")
        except Exception as e:
            print(f"Error loading transducer '{trans_id_to_load}': {e}")
else:
    print("Database directory 'db_dvc' not found.")

if transducer is None:
    print("Using a programmatically generated generic transducer as fallback.")
    transducer = Transducer.gen_matrix_array(nx=8, ny=8, pitch=4, kerf=0.5, id="generic_8x8", name="Generic 8x8 Array", f0=400e3)
    for i, el in enumerate(transducer.elements): el.id = i

# Define other components for the protocol
f0 = transducer.f0 if transducer.f0 else 400e3
pulse = Pulse(frequency=f0, duration=10/f0)
sequence = Sequence(pulse_interval=0.1, pulse_count=1, pulse_train_count=1)
target_pt = Point(position=np.array([0, 0, 40]), units="mm", radius=0.5) # Target at 40mm depth
focal_pattern = focal_patterns.SinglePoint(target_pressure=1.0e6)
apod_method = apod_methods.MaxAngle(max_angle_deg=25)

# Simulation Setup: This defines our grid
# For NIFTI export, it's helpful if the grid is somewhat uniform.
sim_grid_resolution_mm = 0.5 # mm
sim_setup = SimSetup(
    x_extent=(-20, 20), y_extent=(-20, 20), z_extent=(10, 60), # mm
    resolution=sim_grid_resolution_mm
)
print(f"Simulation Setup: {sim_setup}")

protocol = Protocol(
    id='nifti_export_protocol', name='Protocol for NIFTI Export Example',
    pulse=pulse, sequence=sequence, focal_pattern=focal_pattern,
    apod_method=apod_method, sim_setup=sim_setup
)

# Run the solution calculation with simulation enabled
solution = None
sim_res = None
if transducer:
    print(f"\nCalculating solution and running simulation for '{protocol.name}'...")
    try:
        solution, sim_res, analysis = protocol.calc_solution(
            target=target_pt,
            transducer=transducer,
            simulate=True, # Crucial: We need the simulation result
            scale=True     # Scale to target pressure
        )
        if sim_res:
            print(f"Simulation complete. SimResult object obtained.")
            # print(f"  SimResult Peak Pressure: {sim_res.get_peak_pressure()[0]/1e6:.2f} MPa at {sim_res.get_peak_pressure()[1]} mm")
        else:
            print("Simulation did not produce a SimResult object.")
    except Exception as e:
        print(f"Error during solution calculation or simulation: {e}", exc_info=True)
else:
    print("Transducer not available. Cannot run simulation.")
# -

# ## 3. Extracting Data from `SimResult`
#
# The `SimResult` object holds the output of the simulation, including the pressure field and the coordinates of the simulation grid.
# We need to extract:
# 1.  The 3D pressure data as a NumPy array. `SimResult.get_pressure_field()` is expected to provide this.
# 2.  The coordinate vectors for each axis (X, Y, Z). `SimResult.coords` or similar attributes/methods should provide these.

# +
pressure_field_data = None
x_coords, y_coords, z_coords = None, None, None

if sim_res:
    try:
        # Get the pressure field (e.g., p_max or p_rms, depending on what SimResult provides)
        # Let's assume get_pressure_field() returns the max absolute pressure as a 3D NumPy array.
        # The actual method might differ, e.g., sim_res.pressure_field, sim_res.p_max, etc.
        # We need to ensure the data is in a suitable NumPy format (e.g., float32).

        # Based on test_nifti.py, simulation results might be xarray.DataArray
        # ds = openlifu.sim.run_simulation(...) ; ds['p_max'] was used.
        # If sim_res.data is an xarray DataArray named 'pressure':
        if hasattr(sim_res, 'data') and hasattr(sim_res.data, 'pressure'): # Check if it's an xarray-like structure
            pressure_field_data = sim_res.data.pressure.values.astype(np.float32)
            # xarray coordinates are often attached directly
            x_coords = sim_res.data.x.values
            y_coords = sim_res.data.y.values
            z_coords = sim_res.data.z.values
            print("Extracted pressure field and coordinates from xarray-like SimResult.data")
        elif hasattr(sim_res, 'get_pressure_field'): # Hypothetical method
            pressure_field_data = sim_res.get_pressure_field().astype(np.float32)
            x_coords = sim_res.get_x_coords()
            y_coords = sim_res.get_y_coords()
            z_coords = sim_res.get_z_coords()
            print("Extracted pressure field and coordinates using get_... methods.")
        else: # Fallback: try to guess attributes (less robust)
            # This depends heavily on the internal structure of SimResult
            # For example, if sim_res.p_max is the data and sim_res.coords is a dict:
            if hasattr(sim_res, 'p_max') and hasattr(sim_res, 'coords'):
                 pressure_field_data = sim_res.p_max.astype(np.float32) # Example attribute
                 x_coords = sim_res.coords['x'] # Example
                 y_coords = sim_res.coords['y'] # Example
                 z_coords = sim_res.coords['z'] # Example
                 print("Extracted pressure field and coordinates from p_max and coords attributes (guessed).")
            else:
                 print("Could not determine how to extract pressure field and coords from SimResult.")
                 print("Please check the SimResult object structure from your OpenLIFU version.")


        if pressure_field_data is not None:
            print(f"Pressure field data shape: {pressure_field_data.shape}")
            print(f"X coordinates shape: {x_coords.shape}, Y: {y_coords.shape}, Z: {z_coords.shape}")
            # NIFTI expects data typically in (X, Y, Z) order, or rather (i, j, k) which then maps via affine.
            # The order from simulation (e.g. (ax, ele, lat)) needs to be consistent with affine.
            # For nibabel, the array should be indexed Fortran-style if affine has positive X,Y,Z steps.
            # Or, more simply, ensure the array data is laid out as (x_dim, y_dim, z_dim) and use a
            # corresponding affine. Let's assume pressure_field_data is already (X, Y, Z) from OpenLIFU.

    except Exception as e:
        print(f"Error extracting data from SimResult: {e}", exc_info=True)
        pressure_field_data = None
else:
    print("No SimResult object available. Cannot extract data for NIFTI export.")
# -

# ## 4. Constructing the NIFTI Affine Matrix
#
# The affine matrix is crucial for NIFTI. It defines the orientation and position of the image data in physical space (usually RAS - Right-Anterior-Superior coordinates in mm).
# The affine is a 4x4 matrix that transforms voxel coordinates `(i, j, k, 1)` to physical coordinates `(x, y, z, 1)`.
#
# `[[ Mxx Mxy Mxz Tvx ],`
# ` [ Myx Myy Myz Tvy ],`
# ` [ Mzx Mzy Mzz Tvz ],`
# ` [  0   0   0   1  ]]`
#
# Where `M` is a 3x3 rotation/scaling/skew matrix and `Tv` is a translation vector.
# For a simple grid aligned with axes:
# *   The diagonal of `M` contains voxel spacing (dx, dy, dz).
# *   Off-diagonal elements of `M` are zero (no rotation/skew relative to these axes).
# *   `Tv` is the coordinate of the center of the first voxel (index 0,0,0).

# +
affine_matrix = None
if pressure_field_data is not None and x_coords is not None:
    try:
        # Voxel spacing (should match sim_setup.resolution if grid is uniform)
        dx = x_coords[1] - x_coords[0] if len(x_coords) > 1 else sim_grid_resolution_mm
        dy = y_coords[1] - y_coords[0] if len(y_coords) > 1 else sim_grid_resolution_mm
        dz = z_coords[1] - z_coords[0] if len(z_coords) > 1 else sim_grid_resolution_mm
        print(f"Voxel spacing (dx, dy, dz): ({dx:.2f}, {dy:.2f}, {dz:.2f}) mm")

        # Origin: Coordinate of the center of the voxel (0,0,0)
        # NIFTI standard often refers to the corner, but nibabel handles center convention well.
        # For nibabel, it's common to define the affine such that it maps (0,0,0) voxel index
        # to the coordinate of the center of that first voxel.
        origin_x = x_coords[0]
        origin_y = y_coords[0]
        origin_z = z_coords[0]
        print(f"Grid origin (center of first voxel): ({origin_x:.2f}, {origin_y:.2f}, {origin_z:.2f}) mm")

        # Create the affine matrix.
        # Assuming standard OpenLIFU coordinate system (e.g., X, Y, Z)
        # and we want NIFTI to align with these axes.
        # Common NIFTI orientation is RAS (Right-Anterior-Superior).
        # If OpenLIFU's X,Y,Z directly map to X,Y,Z in desired space:
        affine_matrix = np.array([
            [dx,  0,  0, origin_x],
            [ 0, dy,  0, origin_y],
            [ 0,  0, dz, origin_z],
            [ 0,  0,  0,        1]
        ])

        # If OpenLIFU uses a different handedness or axis mapping than your NIFTI viewer expects (e.g. LPS vs RAS),
        # you might need to flip axes in the affine (e.g., by negating dx or dy) and potentially reorder
        # the data array dimensions if you used `np.transpose`.
        # For example, if OpenLIFU X is NIFTI -X (LPS X vs RAS X):
        # affine_matrix[0,0] = -dx
        # affine_matrix[0,3] = origin_x # if origin_x was for the -X direction start.
        # This part is highly dependent on coordinate system conventions.
        # The affine from test_nifti.py was more complex as it included transducer pose.
        # Here, we make a simpler grid-aligned affine.

        print("\nConstructed Affine Matrix:")
        print(affine_matrix)

    except Exception as e:
        print(f"Error constructing affine matrix: {e}", exc_info=True)
        affine_matrix = None
else:
    print("Pressure data or coordinates not available. Cannot construct affine.")
# -

# ## 5. Creating and Saving the NIFTI Image
#
# With the data array and affine matrix, we can create a `Nifti1Image` object using `nibabel` and save it.

# +
output_nifti_filename = "openlifu_simulation.nii.gz"

if pressure_field_data is not None and affine_matrix is not None:
    try:
        # Ensure data is in a suitable orientation for the affine.
        # Nibabel expects Fortran-ordered data for standard axial orientations if data is (X,Y,Z).
        # If pressure_field_data is (Z,Y,X) from simulation, you might need to transpose it
        # and adjust the affine. For now, assume pressure_field_data is (X,Y,Z).
        # If not, you might need:
        # pressure_field_data_xyz = np.transpose(pressure_field_data, (ax_idx_for_x, ax_idx_for_y, ax_idx_for_z))

        print(f"\nCreating NIFTI image with data shape: {pressure_field_data.shape}")
        nifti_image = nibabel.Nifti1Image(pressure_field_data, affine_matrix)

        # Set spatial units in the header (optional but good practice)
        # 1 = NIFTI_UNITS_METER, 2 = NIFTI_UNITS_MM, 3 = NIFTI_UNITS_MICRON
        nifti_image.header.set_xyzt_units(xyz=2, t=0) # xyz in mm, t (time) unspecified (0)

        # Save the NIFTI image
        nibabel.save(nifti_image, output_nifti_filename)
        print(f"âœ… Simulation successfully saved to NIFTI file: {Path(output_nifti_filename).resolve()}")
        print("You can now open this file in a NIFTI viewer (e.g., ITK-SNAP, 3D Slicer, FSLeyes).")

    except Exception as e:
        print(f"Error creating or saving NIFTI image: {e}", exc_info=True)
else:
    print("Pressure data or affine matrix not available. Cannot create NIFTI image.")
# -

# ## 6. Important Considerations for NIFTI Export
#
# *   **Coordinate Systems:** This is the most critical and often confusing part. Ensure your affine matrix correctly maps your simulation's voxel indices to a known physical coordinate system (e.g., RAS). Mismatches will lead to incorrect display or registration with other images. The OpenLIFU coordinate system (how X, Y, Z are defined for the transducer and simulation grid) must be understood.
# *   **Data Orientation:** The order of dimensions in your NumPy array (`pressure_field_data`) must match what the affine matrix expects. If your simulation outputs data as `(z, y, x)` but your affine is set up for `(x, y, z)` voxel indexing, you'll need to transpose the data. `nibabel.as_closest_canonical(img)` can sometimes help reorient data to a more standard axial view, but the underlying data-to-affine mapping must be correct.
# *   **Data Type:** `float32` is common for NIFTI images representing continuous values like pressure.
# *   **Header Information:** Setting units (`set_xyzt_units`) and other header fields can be important for compatibility with some software.
# *   **Transducer Position:** If you want to align the simulation NIFTI with a NIFTI representing anatomy where the transducer has a known pose, you'd need to incorporate the transducer's transformation matrix into the NIFTI affine, or register the simulation NIFTI to the anatomical NIFTI using image registration tools. The example here creates a NIFTI in the simulation's own coordinate frame.

# ## 7. Conclusion
#
# This notebook demonstrated a basic workflow for exporting OpenLIFU simulation results to the NIFTI format. This enables visualization and analysis in a wide range of medical imaging tools, facilitating the integration of simulation data with other imaging modalities.
#
# Accurate NIFTI export hinges on correctly defining the affine transformation that links the voxel data to physical space. Careful attention to coordinate systems and data orientation is paramount.

# End of Notebook 13
